# 																	分布式高并发本质精髓杂记

> **分布式存储系统从本质上就是实现分布式Hash表或者分布式B+树。**
>
> **日志是分布式系统的基石！**
>
> 分布式核心思想：　**分治，　冗余**，　**日志**、**归并**。
>
> **尽可能减小锁粒度，避免阻塞为并发和异步关键！！！！**
>
> **因为阻塞意味着线程切换，context save/load、缓存被覆盖**
>
> **简单是可靠性的先决条件**
>
> **－－－－－－－－－－－－－－－－－－－－－－－－－－－－－**
>
> **优化（延迟和吞吐）**
>
> **１．计算要尽可能靠近数据存储，从而尽可能减少数据复制，减少网络请求次数和延迟！移动数据不如移动计算！**
>
> **２．分而治之，数据和负载分流**
>
> **３．缓存，缓存命中，替换、局部原则要注意，避免跳转缓存失**
>
> **４．读写高效，权衡存储介质和网络性能，ＩＯ代价，读写可分离，批量读写，动静分离，****尽量避免远程调用、大量I/O等耗时操作**
>
> **５．并行/并发处理**
>
> **６．数据分布均匀有序，point/range 访问要高效，索引，数据结构和算法直接决定读写和计算代价**
>
> **７．阻塞是并发/异步处理的大敌！！！**
>
> **８．高性能计算数学优化方法，比如：`HyperLogLogs` 大量节省空间和计算资源**
>
> **９．分布式事务和单机事务需谨慎考量**
>
> **１０．数据副本一致性如何保障！时空代价？数据一致性代价考量，共识协议最关键**
>
> **１１．求人难，少求人！自己干，出错少！数据大分一分，各干各不干扰！有事商量要高效，共识代价要可控！**
>
> **１２．争抢和出错是常态，询问、质问、确认、反复，共识代价太高昂，悲观处事活太累！**
>
> **１３．争抢和出错是偶然，你让我等，免冲突，潇洒不多问，时效难保证，乐观有代价！**
>
> **１４．锁是双刃剑，莫要轻率用，`MVCC`多版本访问控制很关键**
>
> **１５．超时机制很重要，避免等待无穷期**
>
> **１６．查询要优化，避免无用功**
>
> **１７．请求太多队列化，生产消费要分离，读写并发不干扰，特别是重计算务必分流并且队列化批处理**
>
> **１８．异步编程，`goroutine`，ＩＯ复用，事半功倍好利器**
>
> **１９．`os`微内核、用户空间driver, 用户空间`tcp/ip`协议栈，总之`os`是瓶颈，避免数据复制忙**
>
> **２０．集群水平垂直扩展易，性能直线有提升，by data range 或者hash 水平扩展**
>
> **２１．增加预计算处理，尽可能减少实时计算处理**
>
> **２２．copy on write**
>
> **２３．使用搜索引擎/`KV`代替直接检索关系数据库**
>
> **２４．锁及同步要慎用，避免死锁、过度串行化、降低并发度！**
>
> **２５．线程，闭包，协程，同步推进要有序，分离归并要清晰，前因后果顺序明确！总之并发不是混乱各自为政，关键是协作有道！！！**
>
> **26. 提高并发度主要在于解耦设计，分工协作**
>
> **２７．提高吞吐率主要在于尽可能少的上下文切换和调度，专心计算，充分利用ＣＰＵ，所以进程、线程、协程也好，同步异步编程也好，ＩＯ复用也好，可以提高并发度，　但是真正解决问题主要在于计算，避免频繁调度切换打扰CPU计算！**
>
> **28. 避免重复和无关低效计算**
>
> **－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－**
>
> **容错：网络不可靠，数据可丢失！**
>
> **０．日志是命根，redo,undo要记牢，数据未动先日志，日志先落地宕机也无妨！**
>
> **１．狡兔有三窟，data要副本，鸡蛋莫放统一篮**
>
> **２．有问必有答，此事才生效！**
>
> **３.　事前仔细，事后对账！**
>
> **４．共识协议要可靠，副本一致全靠它**
>
> **５．网络请求有３态：成功，失败，超时，莫要糊涂搞混乱。**
>
> **６．数据校验要跟上，避免错误、缺失、篡改**
>
> **７．`２pc/3pc` 事务算法要盯牢**
>
> **８．心跳, 因为`TCP/IP`不是轮询的**
>
> **９．定期上报**
>
> **１０．超时，远端突然挂了，比如断电，　所以read操作要有timeout；　write要检查`EPIPE`;** 
>
> **１１．调度和路由**
>
> **１２．理解`tcp/ip`的尽力原则，虚链路随时可能中断或延迟，数据残缺粘连、远端实体崩溃或远端主机崩溃，断电等，`TCP/IP`可靠但不绝对可靠**
>
> **１３．不要假设peer node 一直alive**
>
> **１４．****`SIGCHLD`（子进程回收避免僵尸进程）****、`SIGPIPE`信号必须处理（比如屏蔽,) `SIGPIPE`信号发生时，系统调用此时返回-1, `errno:EPIPE`**
>
> **１５．重启被信号中断的系统调用，系统调用此时返回-1,` errno:EINTR默认linux`会自动重启，但是开发者也要注意。**
>
> **１６．避免缓冲区溢出**
>
> **１７．避免`TCP/IP:TIME_WAIT`暗杀，主动正常关闭TCP连接，主动方都会出现`TIMEWAI`T，所以有人建议server断不要频繁主动关闭client socket???**
>
> **18. Linux Socket关键参数：`SO_REUSEADDR`,** `**SO_REUSEPORT`****,**`http://man7.org/linux/man-pages/man7/socket.7.html`
>
> **19.确保正确字节序，大端小端字节序，网络字节序为大端**
>
> **２０．返回值要检查，收发字节数也要查，解包封包也重要，收发速率要同步**
>
> **２１．资源回收要可靠，避免内存被撑爆**
>
> **２２．避免data　复制**
>
> **２３．采用通用数据包格式，因为并不是所有网络程序都是C/C++编写的！所以数据类型，大小，对齐填充，字节序等很可能不同。**
>
> **２４．堤防远端实体的不友好动作，防御编程，检测远端生死和数据合法有效性**
>
> **２５．TCP流协议，收到数据要字节拆分包，可能包不全或这粘连其他包；发送一个独立包其实汇入字节流，包格式，拆包封包方法要设计**
>
> **26. 当一个流程中多个操作必须依次顺序整体执行成功，不可打断，结果（数据）才正确的话，那么这个流程开始到结束的范围必须被一把锁保护，从而确保其原子性！事务、分布式事务是这个锁的高层次称呼。　如：**
>
> `fn aflow() {`
>
> **`lock_start`**
>
> **`op1`**
>
> **`op2`**
>
> **`op3`**
>
> **...**
>
> **`lock_end`**
>
> };**我们实际开发时可能犯晕，想当然地以为为每个操作单独加锁就够了，其实每个操作单独加锁，只是保证这个操作的原子性/排他性！但是此流程各个操作之间的顺序和整体性，既流程的原子性没有保证！通常高并发、异步编程时，一味地追求并发度，忽略了某些流程具有事务属性，其中的操作必须整体执行成功或失败！不能被打断，切记！！！**
>
> **２７.　对于并发/异步编程，锁只解决原子性（事务）排他性问题，　而各种同步原语负责解决协作（串行、并行、分开、汇集点，等待）和先后顺序问题！**
>
> 

------

# 分布式原理技术汇集

> １．哈希，一致性哈希
>
> ２．矢量（向量）时钟
>
> ３．Gossip的成员和故障检测协议
>
> ４．`Merkle`树
>
> ５．多副本，复制
>
> ６．一致性共识协议，`paxos/raft`
>
> ７．redo/undo日志
>
> ８．快照
>
> ９．分布式事务，`2pc/3p`c等
>
> １０．B/B+树，　`LSM`
>
> １１．`MVCC` ，时间戳
>
> １２．基线数据、增量数据
>
> １３．读写分离
>
> １４．批量写，写时复制
>
> １５．ACID/CAP/BASE权衡
>
> １６．强制一次同步/异步写多副本，一次读多副本
>
> １７．心跳
>
> １８．避免死锁
>
> １９．`Raft /paxos group`，包括多个副本，其中一个为主副本，实现副本在多节点上的同步复制和一致性。
>
> `RocksDB` 性能很强，但它是单机的，为了保证高可用性，因此使用副本的机制。
>
> ２０． Lease 租约
>
> ２１．分布式哈希，分布式B/B+树
>
> ２２．无状态`TiDB` 配合有状态`TiKV`, 高效单机存储引擎`RocksDB`, Raft Group, 以及Range数据分片meta PD.
>
> 23. 非对称加密技术。

------

# 分布式大数据高并发数据结构和算法

> 1. `哈希、哈希表`
> 2. `Bitvector/Bitmap`
> 3. ` Bloom filter`
> 4. `SkipList（跳表）`
> 5. `LSM树`
> 6. `HashTree/梅克尔树`
> 7. `B树/B+树`
> 8. `红黑树`
> 9. `Trie字典树`
> 10. `HyperLogLog`
> 11. `AVL Tree`
> 12. `堆排序（大顶堆、小顶堆）`
> 13. `外部排序`
> 14. `mapreduce/多层划分`
> 15. `有序数组`
> 16. `倒排索引`
> 17. `Count-Min Sketch频率估计算法`
> 18. `Cuckoo哈希`

------

# 低延迟系统的 11 个最佳实践

> 1. 选择正确的编程语言（如`Asm/C/C++/Rust`）
> 2. 把一切放在内存里（现在而言CPU的缓存最快，次之就是内存）
> 3. 确保系统未充分使用（未达极限，留有余力应对突发）
> 4. 确保数据和处理尽可能靠近（比如将请求派发给拥有对应数据的Local Host,确保处理的数据就在手边,避免数据复制）
> 5. 确保最小化上下文切换（比如线程数与CPU内核数不匹配，太多线程调度切换造成计算资源浪费，过犹不及）
> 6. （顺序读）确保读操作的顺序性连续性（通常各种存储设备顺序连续读写的性能都明显好于随机读写跳跃读写，有利于各级缓存的预处理，避免缓存失效和寻址的消耗）
> 7. 批量写（需要等待汇集数据，牺牲实时性，但确实可以提升写性能，特别对于机械硬盘更是如此，批量顺序连续写入数据性能最好）
> 8. 优化缓存（编程时考虑采用什么内存数据结构和磁盘文件存储结构关乎缓存效率，尽可能确保缓存预处理，命中，避免失效）
> 9. 尽可能多地使用非阻塞模式（避免User space mode 和Kernel space mode之间频繁的切换消耗）
> 10. 尽可能多地使用异步（特别对于IO类， 事件类程序，避免因为等待而令CPU空转）
> 11. 尽可能多地使用并行（充分利用CPU, 充分利用分布式计算，多节点同时并行处理）
>
> `以上都是前辈高人总结分享的， 我也加了点我的理解！`





- Author

> 学习随笔杂记心得，日常收集，备忘录，难免谬误！
>
> 作者：心尘了
>
> email: 285779289@qq.com
>
> git：https://github.com/yujinliang





- Reference

> `笔记为长时间收集所得， 时间长，资料繁多， 随机记录， 难以准确列出所有出处， 在此统一感谢原作者的辛勤付出`